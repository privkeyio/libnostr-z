const std = @import("std");
const crypto = @import("crypto.zig");

const ec = @cImport({
    @cInclude("openssl/ec.h");
    @cInclude("openssl/bn.h");
    @cInclude("openssl/obj_mac.h");
});

pub const Error = error{
    InvalidKey,
    PassphraseTooLong,
};

const SECP256K1_ORDER = [32]u8{
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
    0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
    0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41,
};

const HmacSha512 = std.crypto.auth.hmac.sha2.HmacSha512;

fn getCompressedPubkey(secret_key: *const [32]u8, compressed_out: *[33]u8) !void {
    const group = ec.EC_GROUP_new_by_curve_name(ec.NID_secp256k1);
    if (group == null) return Error.InvalidKey;
    defer ec.EC_GROUP_free(group);

    const bn_key = ec.BN_bin2bn(secret_key, 32, null);
    if (bn_key == null) return Error.InvalidKey;
    defer ec.BN_free(bn_key);

    const point = ec.EC_POINT_new(group);
    if (point == null) return Error.InvalidKey;
    defer ec.EC_POINT_free(point);

    if (ec.EC_POINT_mul(group, point, bn_key, null, null, null) != 1) {
        return Error.InvalidKey;
    }

    const len = ec.EC_POINT_point2oct(group, point, ec.POINT_CONVERSION_COMPRESSED, compressed_out, 33, null);
    if (len != 33) return Error.InvalidKey;
}

pub fn mnemonicToSeed(mnemonic: []const u8, passphrase: []const u8, seed_out: *[64]u8) Error!void {
    if (passphrase.len > 256) return Error.PassphraseTooLong;

    var salt_buf: [8 + 256]u8 = undefined;
    const salt_prefix = "mnemonic";
    @memcpy(salt_buf[0..8], salt_prefix);
    const salt_len = 8 + passphrase.len;
    if (passphrase.len > 0) {
        @memcpy(salt_buf[8 .. 8 + passphrase.len], passphrase);
    }
    const salt = salt_buf[0..salt_len];

    pbkdf2HmacSha512(mnemonic, salt, 2048, seed_out);
}

fn pbkdf2HmacSha512(password: []const u8, salt: []const u8, iterations: u32, out: *[64]u8) void {
    var u: [64]u8 = undefined;
    var t: [64]u8 = undefined;

    var hmac = HmacSha512.init(password);
    hmac.update(salt);
    hmac.update(&[_]u8{ 0, 0, 0, 1 });
    hmac.final(&u);
    t = u;

    var i: u32 = 1;
    while (i < iterations) : (i += 1) {
        var hmac2 = HmacSha512.init(password);
        hmac2.update(&u);
        hmac2.final(&u);
        for (0..64) |j| {
            t[j] ^= u[j];
        }
    }

    out.* = t;
}

fn masterKeyFromSeed(seed: []const u8, secret_key: *[32]u8, chain_code: *[32]u8) void {
    var hmac = HmacSha512.init("Bitcoin seed");
    hmac.update(seed);
    var result: [64]u8 = undefined;
    hmac.final(&result);
    secret_key.* = result[0..32].*;
    chain_code.* = result[32..64].*;
}

fn deriveHardenedChild(parent_key: *const [32]u8, parent_chain: *const [32]u8, index: u32, child_key: *[32]u8, child_chain: *[32]u8) !void {
    const hardened_index = index | 0x80000000;
    var data: [37]u8 = undefined;
    defer @memset(&data, 0);
    data[0] = 0;
    @memcpy(data[1..33], parent_key);
    std.mem.writeInt(u32, data[33..37], hardened_index, .big);

    var hmac = HmacSha512.init(parent_chain);
    hmac.update(&data);
    var result: [64]u8 = undefined;
    defer @memset(&result, 0);
    hmac.final(&result);

    const il = result[0..32];
    child_chain.* = result[32..64].*;

    addPrivateKeys(parent_key, il, child_key) catch return Error.InvalidKey;
}

fn deriveNormalChild(parent_key: *const [32]u8, parent_chain: *const [32]u8, index: u32, child_key: *[32]u8, child_chain: *[32]u8) !void {
    var compressed_pubkey: [33]u8 = undefined;
    try getCompressedPubkey(parent_key, &compressed_pubkey);

    var data: [37]u8 = undefined;
    @memcpy(data[0..33], &compressed_pubkey);
    std.mem.writeInt(u32, data[33..37], index, .big);

    var hmac = HmacSha512.init(parent_chain);
    hmac.update(&data);
    var result: [64]u8 = undefined;
    defer @memset(&result, 0);
    hmac.final(&result);

    const il = result[0..32];
    child_chain.* = result[32..64].*;

    addPrivateKeys(parent_key, il, child_key) catch return Error.InvalidKey;
}

const TWO_POW_256_MINUS_N = [32]u8{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x45, 0x51, 0x23, 0x19, 0x50, 0xB7, 0x5F, 0xC4,
    0x40, 0x2D, 0xA1, 0x73, 0x2F, 0xC9, 0xBE, 0xBF,
};

fn addPrivateKeys(a: *const [32]u8, b: *const [32]u8, result: *[32]u8) !void {
    var carry: u16 = 0;
    var sum: [32]u8 = undefined;

    var i: usize = 32;
    while (i > 0) {
        i -= 1;
        const s = @as(u16, a[i]) + @as(u16, b[i]) + carry;
        sum[i] = @truncate(s);
        carry = s >> 8;
    }

    if (carry == 1) {
        _ = addNoMod(&sum, &TWO_POW_256_MINUS_N, result);
    } else if (compare(&sum, &SECP256K1_ORDER) >= 0) {
        subtract(&sum, &SECP256K1_ORDER, result);
    } else {
        result.* = sum;
    }

    if (isZero(result)) return Error.InvalidKey;
}

fn addNoMod(a: *const [32]u8, b: *const [32]u8, result: *[32]u8) u16 {
    var carry: u16 = 0;
    var i: usize = 32;
    while (i > 0) {
        i -= 1;
        const s = @as(u16, a[i]) + @as(u16, b[i]) + carry;
        result[i] = @truncate(s);
        carry = s >> 8;
    }
    return carry;
}

fn compare(a: *const [32]u8, b: *const [32]u8) i32 {
    for (0..32) |i| {
        if (a[i] < b[i]) return -1;
        if (a[i] > b[i]) return 1;
    }
    return 0;
}

fn subtract(a: *const [32]u8, b: *const [32]u8, result: *[32]u8) void {
    var borrow: i16 = 0;
    var i: usize = 32;
    while (i > 0) {
        i -= 1;
        const diff = @as(i16, a[i]) - @as(i16, b[i]) - borrow;
        if (diff < 0) {
            result[i] = @intCast(diff + 256);
            borrow = 1;
        } else {
            result[i] = @intCast(diff);
            borrow = 0;
        }
    }
}

fn isZero(key: *const [32]u8) bool {
    for (key) |b| {
        if (b != 0) return false;
    }
    return true;
}

pub fn keypairFromMnemonic(mnemonic: []const u8, passphrase: []const u8, account: u32) !struct { secret_key: [32]u8, public_key: [32]u8 } {
    var seed: [64]u8 = undefined;
    defer @memset(&seed, 0);
    try mnemonicToSeed(mnemonic, passphrase, &seed);

    var key: [32]u8 = undefined;
    var chain: [32]u8 = undefined;
    defer @memset(&key, 0);
    defer @memset(&chain, 0);
    masterKeyFromSeed(&seed, &key, &chain);

    var child_key: [32]u8 = undefined;
    var child_chain: [32]u8 = undefined;
    defer @memset(&child_key, 0);
    defer @memset(&child_chain, 0);

    try deriveHardenedChild(&key, &chain, 44, &child_key, &child_chain);
    key = child_key;
    chain = child_chain;

    try deriveHardenedChild(&key, &chain, 1237, &child_key, &child_chain);
    key = child_key;
    chain = child_chain;

    try deriveHardenedChild(&key, &chain, account, &child_key, &child_chain);
    key = child_key;
    chain = child_chain;

    try deriveNormalChild(&key, &chain, 0, &child_key, &child_chain);
    key = child_key;
    chain = child_chain;

    try deriveNormalChild(&key, &chain, 0, &child_key, &child_chain);

    var public_key: [32]u8 = undefined;
    crypto.getPublicKey(&child_key, &public_key) catch return Error.InvalidKey;

    const result_key = child_key;
    return .{ .secret_key = result_key, .public_key = public_key };
}

test "nip06 test vector 1" {
    const event_mod = @import("event.zig");
    try event_mod.init();
    defer event_mod.cleanup();

    const mnemonic = "leader monkey parrot ring guide accident before fence cannon height naive bean";
    const result = try keypairFromMnemonic(mnemonic, "", 0);

    const expected_sk = [_]u8{ 0x7f, 0x7f, 0xf0, 0x3d, 0x12, 0x37, 0x92, 0xd6, 0xac, 0x59, 0x4b, 0xfa, 0x67, 0xbf, 0x6d, 0x0c, 0x0a, 0xb5, 0x5b, 0x6b, 0x1f, 0xdb, 0x62, 0x49, 0x30, 0x3f, 0xe8, 0x61, 0xf1, 0xcc, 0xba, 0x9a };
    try std.testing.expectEqualSlices(u8, &expected_sk, &result.secret_key);

    const expected_pk = [_]u8{ 0x17, 0x16, 0x2c, 0x92, 0x1d, 0xc4, 0xd2, 0x51, 0x8f, 0x9a, 0x10, 0x1d, 0xb3, 0x36, 0x95, 0xdf, 0x1a, 0xfb, 0x56, 0xab, 0x82, 0xf5, 0xff, 0x3e, 0x5d, 0xa6, 0xee, 0xc3, 0xca, 0x5c, 0xd9, 0x17 };
    try std.testing.expectEqualSlices(u8, &expected_pk, &result.public_key);
}

test "nip06 test vector 2" {
    const event_mod = @import("event.zig");
    try event_mod.init();
    defer event_mod.cleanup();

    const mnemonic = "what bleak badge arrange retreat wolf trade produce cricket blur garlic valid proud rude strong choose busy staff weather area salt hollow arm fade";
    const result = try keypairFromMnemonic(mnemonic, "", 0);

    const expected_sk = [_]u8{ 0xc1, 0x5d, 0x73, 0x98, 0x94, 0xc8, 0x1a, 0x2f, 0xcf, 0xd3, 0xa2, 0xdf, 0x85, 0xa0, 0xd2, 0xc0, 0xdb, 0xc4, 0x7a, 0x28, 0x0d, 0x09, 0x27, 0x99, 0xf1, 0x44, 0xd7, 0x3d, 0x7a, 0xe7, 0x8a, 0xdd };
    try std.testing.expectEqualSlices(u8, &expected_sk, &result.secret_key);

    const expected_pk = [_]u8{ 0xd4, 0x1b, 0x22, 0x89, 0x95, 0x49, 0xe1, 0xf3, 0xd3, 0x35, 0xa3, 0x10, 0x02, 0xcf, 0xd3, 0x82, 0x17, 0x40, 0x06, 0xe1, 0x66, 0xd3, 0xe6, 0x58, 0xe3, 0xa5, 0xee, 0xcd, 0xb6, 0x46, 0x35, 0x73 };
    try std.testing.expectEqualSlices(u8, &expected_pk, &result.public_key);
}

test "pbkdf2 hmac-sha512" {
    var out: [64]u8 = undefined;
    pbkdf2HmacSha512("password", "salt", 1, &out);

    const expected = [_]u8{
        0x86, 0x7f, 0x70, 0xcf, 0x1a, 0xde, 0x02, 0xcf, 0xf3, 0x75, 0x25, 0x99, 0xa3, 0xa5, 0x3d, 0xc4,
        0xaf, 0x34, 0xc7, 0xa6, 0x69, 0x81, 0x5a, 0xe5, 0xd5, 0x13, 0x55, 0x4e, 0x1c, 0x8c, 0xf2, 0x52,
        0xc0, 0x2d, 0x47, 0x0a, 0x28, 0x5a, 0x05, 0x01, 0xba, 0xd9, 0x99, 0xbf, 0xe9, 0x43, 0xc0, 0x8f,
        0x05, 0x02, 0x35, 0xd7, 0xd6, 0x8b, 0x1d, 0xa5, 0x5e, 0x63, 0xf7, 0x3b, 0x60, 0xa5, 0x7f, 0xce,
    };
    try std.testing.expectEqualSlices(u8, &expected, &out);
}

test "bip32 master key derivation" {
    const seed = [_]u8{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
    var key: [32]u8 = undefined;
    var chain: [32]u8 = undefined;
    masterKeyFromSeed(&seed, &key, &chain);

    const expected_key = [_]u8{ 0xe8, 0xf3, 0x2e, 0x72, 0x3d, 0xec, 0xf4, 0x05, 0x1a, 0xef, 0xac, 0x8e, 0x2c, 0x93, 0xc9, 0xc5, 0xb2, 0x14, 0x31, 0x38, 0x17, 0xcd, 0xb0, 0x1a, 0x14, 0x94, 0xb9, 0x17, 0xc8, 0x43, 0x6b, 0x35 };
    const expected_chain = [_]u8{ 0x87, 0x3d, 0xff, 0x81, 0xc0, 0x2f, 0x52, 0x56, 0x23, 0xfd, 0x1f, 0xe5, 0x16, 0x7e, 0xac, 0x3a, 0x55, 0xa0, 0x49, 0xde, 0x3d, 0x31, 0x4b, 0xb4, 0x2e, 0xe2, 0x27, 0xff, 0xed, 0x37, 0xd5, 0x08 };

    try std.testing.expectEqualSlices(u8, &expected_key, &key);
    try std.testing.expectEqualSlices(u8, &expected_chain, &chain);
}

test "bip39 mnemonic to seed" {
    const mnemonic = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
    var seed: [64]u8 = undefined;
    try mnemonicToSeed(mnemonic, "", &seed);

    const expected = [_]u8{
        0x5e, 0xb0, 0x0b, 0xbd, 0xdc, 0xf0, 0x69, 0x08, 0x48, 0x89, 0xa8, 0xab, 0x91, 0x55, 0x56, 0x81,
        0x65, 0xf5, 0xc4, 0x53, 0xcc, 0xb8, 0x5e, 0x70, 0x81, 0x1a, 0xae, 0xd6, 0xf6, 0xda, 0x5f, 0xc1,
        0x9a, 0x5a, 0xc4, 0x0b, 0x38, 0x9c, 0xd3, 0x70, 0xd0, 0x86, 0x20, 0x6d, 0xec, 0x8a, 0xa6, 0xc4,
        0x3d, 0xae, 0xa6, 0x69, 0x0f, 0x20, 0xad, 0x3d, 0x8d, 0x48, 0xb2, 0xd2, 0xce, 0x9e, 0x38, 0xe4,
    };
    try std.testing.expectEqualSlices(u8, &expected, &seed);
}

test "bip32 hardened child derivation m/0'" {
    const event_mod = @import("event.zig");
    try event_mod.init();
    defer event_mod.cleanup();

    const parent_key = [_]u8{ 0xe8, 0xf3, 0x2e, 0x72, 0x3d, 0xec, 0xf4, 0x05, 0x1a, 0xef, 0xac, 0x8e, 0x2c, 0x93, 0xc9, 0xc5, 0xb2, 0x14, 0x31, 0x38, 0x17, 0xcd, 0xb0, 0x1a, 0x14, 0x94, 0xb9, 0x17, 0xc8, 0x43, 0x6b, 0x35 };
    const parent_chain = [_]u8{ 0x87, 0x3d, 0xff, 0x81, 0xc0, 0x2f, 0x52, 0x56, 0x23, 0xfd, 0x1f, 0xe5, 0x16, 0x7e, 0xac, 0x3a, 0x55, 0xa0, 0x49, 0xde, 0x3d, 0x31, 0x4b, 0xb4, 0x2e, 0xe2, 0x27, 0xff, 0xed, 0x37, 0xd5, 0x08 };

    var child_key: [32]u8 = undefined;
    var child_chain: [32]u8 = undefined;
    try deriveHardenedChild(&parent_key, &parent_chain, 0, &child_key, &child_chain);

    const expected_key = [_]u8{ 0xed, 0xb2, 0xe1, 0x4f, 0x9e, 0xe7, 0x7d, 0x26, 0xdd, 0x93, 0xb4, 0xec, 0xed, 0xe8, 0xd1, 0x6e, 0xd4, 0x08, 0xce, 0x14, 0x9b, 0x6c, 0xd8, 0x0b, 0x07, 0x15, 0xa2, 0xd9, 0x11, 0xa0, 0xaf, 0xea };
    const expected_chain = [_]u8{ 0x47, 0xfd, 0xac, 0xbd, 0x0f, 0x10, 0x97, 0x04, 0x3b, 0x78, 0xc6, 0x3c, 0x20, 0xc3, 0x4e, 0xf4, 0xed, 0x9a, 0x11, 0x1d, 0x98, 0x00, 0x47, 0xad, 0x16, 0x28, 0x2c, 0x7a, 0xe6, 0x23, 0x61, 0x41 };

    try std.testing.expectEqualSlices(u8, &expected_key, &child_key);
    try std.testing.expectEqualSlices(u8, &expected_chain, &child_chain);
}

test "bip32 normal child derivation m/0'/1" {
    const parent_key = [_]u8{ 0xed, 0xb2, 0xe1, 0x4f, 0x9e, 0xe7, 0x7d, 0x26, 0xdd, 0x93, 0xb4, 0xec, 0xed, 0xe8, 0xd1, 0x6e, 0xd4, 0x08, 0xce, 0x14, 0x9b, 0x6c, 0xd8, 0x0b, 0x07, 0x15, 0xa2, 0xd9, 0x11, 0xa0, 0xaf, 0xea };
    const parent_chain = [_]u8{ 0x47, 0xfd, 0xac, 0xbd, 0x0f, 0x10, 0x97, 0x04, 0x3b, 0x78, 0xc6, 0x3c, 0x20, 0xc3, 0x4e, 0xf4, 0xed, 0x9a, 0x11, 0x1d, 0x98, 0x00, 0x47, 0xad, 0x16, 0x28, 0x2c, 0x7a, 0xe6, 0x23, 0x61, 0x41 };

    var child_key: [32]u8 = undefined;
    var child_chain: [32]u8 = undefined;
    try deriveNormalChild(&parent_key, &parent_chain, 1, &child_key, &child_chain);

    const expected_key = [_]u8{ 0x3c, 0x6c, 0xb8, 0xd0, 0xf6, 0xa2, 0x64, 0xc9, 0x1e, 0xa8, 0xb5, 0x03, 0x0f, 0xad, 0xaa, 0x8e, 0x53, 0x8b, 0x02, 0x0f, 0x0a, 0x38, 0x74, 0x21, 0xa1, 0x2d, 0xe9, 0x31, 0x9d, 0xc9, 0x33, 0x68 };
    const expected_chain = [_]u8{ 0x2a, 0x78, 0x57, 0x63, 0x13, 0x86, 0xba, 0x23, 0xda, 0xca, 0xc3, 0x41, 0x80, 0xdd, 0x19, 0x83, 0x73, 0x4e, 0x44, 0x4f, 0xdb, 0xf7, 0x74, 0x04, 0x15, 0x78, 0xe9, 0xb6, 0xad, 0xb3, 0x7c, 0x19 };

    try std.testing.expectEqualSlices(u8, &expected_chain, &child_chain);
    try std.testing.expectEqualSlices(u8, &expected_key, &child_key);
}

test "compressed pubkey generator point" {
    var secret_key: [32]u8 = [_]u8{0} ** 32;
    secret_key[31] = 1;
    var compressed: [33]u8 = undefined;
    try getCompressedPubkey(&secret_key, &compressed);

    const expected = [_]u8{
        0x02, 0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC, 0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B,
        0x07, 0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9, 0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98,
    };
    try std.testing.expectEqualSlices(u8, &expected, &compressed);
}

test "modular addition" {
    const a = [_]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    const b = [_]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 };
    var result: [32]u8 = undefined;
    try addPrivateKeys(&a, &b, &result);

    const expected = [_]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03 };
    try std.testing.expectEqualSlices(u8, &expected, &result);
}

test "modular addition with wrap" {
    const n_minus_1 = [_]u8{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x40 };
    const one = [_]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
    var result: [32]u8 = undefined;
    try std.testing.expectError(Error.InvalidKey, addPrivateKeys(&n_minus_1, &one, &result));
}

test "compressed pubkey x matches noscrypt" {
    const event_mod = @import("event.zig");
    try event_mod.init();
    defer event_mod.cleanup();

    const secret_key = [_]u8{ 0xed, 0xb2, 0xe1, 0x4f, 0x9e, 0xe7, 0x7d, 0x26, 0xdd, 0x93, 0xb4, 0xec, 0xed, 0xe8, 0xd1, 0x6e, 0xd4, 0x08, 0xce, 0x14, 0x9b, 0x6c, 0xd8, 0x0b, 0x07, 0x15, 0xa2, 0xd9, 0x11, 0xa0, 0xaf, 0xea };

    var x_only: [32]u8 = undefined;
    try crypto.getPublicKey(&secret_key, &x_only);

    var compressed: [33]u8 = undefined;
    try getCompressedPubkey(&secret_key, &compressed);

    try std.testing.expectEqualSlices(u8, &x_only, compressed[1..33]);
}

test "verify openssl pubkey with bip32 master" {
    const master_key = [_]u8{ 0xe8, 0xf3, 0x2e, 0x72, 0x3d, 0xec, 0xf4, 0x05, 0x1a, 0xef, 0xac, 0x8e, 0x2c, 0x93, 0xc9, 0xc5, 0xb2, 0x14, 0x31, 0x38, 0x17, 0xcd, 0xb0, 0x1a, 0x14, 0x94, 0xb9, 0x17, 0xc8, 0x43, 0x6b, 0x35 };

    var compressed: [33]u8 = undefined;
    try getCompressedPubkey(&master_key, &compressed);

    const expected = [_]u8{ 0x03, 0x39, 0xa3, 0x60, 0x13, 0x30, 0x15, 0x97, 0xda, 0xef, 0x41, 0xfb, 0xe5, 0x93, 0xa0, 0x2c, 0xc5, 0x13, 0xd0, 0xb5, 0x55, 0x27, 0xec, 0x2d, 0xf1, 0x05, 0x0e, 0x2e, 0x8f, 0xf4, 0x9c, 0x85, 0xc2 };
    try std.testing.expectEqualSlices(u8, &expected, &compressed);
}

test "verify openssl pubkey with bip32 m/0'" {
    const m0h_key = [_]u8{ 0xed, 0xb2, 0xe1, 0x4f, 0x9e, 0xe7, 0x7d, 0x26, 0xdd, 0x93, 0xb4, 0xec, 0xed, 0xe8, 0xd1, 0x6e, 0xd4, 0x08, 0xce, 0x14, 0x9b, 0x6c, 0xd8, 0x0b, 0x07, 0x15, 0xa2, 0xd9, 0x11, 0xa0, 0xaf, 0xea };

    var compressed: [33]u8 = undefined;
    try getCompressedPubkey(&m0h_key, &compressed);

    const expected = [_]u8{ 0x03, 0x5a, 0x78, 0x46, 0x62, 0xa4, 0xa2, 0x0a, 0x65, 0xbf, 0x6a, 0xab, 0x9a, 0xe9, 0x8a, 0x6c, 0x06, 0x8a, 0x81, 0xc5, 0x2e, 0x4b, 0x03, 0x2c, 0x0f, 0xb5, 0x40, 0x0c, 0x70, 0x6c, 0xfc, 0xcc, 0x56 };
    try std.testing.expectEqualSlices(u8, &expected, &compressed);
}

